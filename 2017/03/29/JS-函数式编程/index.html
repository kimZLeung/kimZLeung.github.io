<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JS 函数式编程," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/upload.jpg?v=5.1.0" />






<meta name="description" content="以前我眼里的函数式编程
纯函数、不影响外部状态、高抽象度… 没… 没了吧。从一而终的纯函数，不受任何外部变量影响，也不影响任何外部变量的高度抽象性。大概就是我所认为的函数式编程的最迷人的地方，但是，貌似也仅此而已。

有什么用啊…? 我也不知道除了写redux的时候就没用过了
这是纯函数被黑的最惨的一次 QwQ


从了解curry开始
恩，函数式编程的世界里的确到处充满着纯函数。可以说纯函数从头">
<meta property="og:type" content="article">
<meta property="og:title" content="JS-函数式编程">
<meta property="og:url" content="http://kimzZ.com/2017/03/29/JS-函数式编程/index.html">
<meta property="og:site_name" content="kimZLeung">
<meta property="og:description" content="以前我眼里的函数式编程
纯函数、不影响外部状态、高抽象度… 没… 没了吧。从一而终的纯函数，不受任何外部变量影响，也不影响任何外部变量的高度抽象性。大概就是我所认为的函数式编程的最迷人的地方，但是，貌似也仅此而已。

有什么用啊…? 我也不知道除了写redux的时候就没用过了
这是纯函数被黑的最惨的一次 QwQ


从了解curry开始
恩，函数式编程的世界里的确到处充满着纯函数。可以说纯函数从头">
<meta property="og:updated_time" content="2017-03-28T15:03:55.715Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS-函数式编程">
<meta name="twitter:description" content="以前我眼里的函数式编程
纯函数、不影响外部状态、高抽象度… 没… 没了吧。从一而终的纯函数，不受任何外部变量影响，也不影响任何外部变量的高度抽象性。大概就是我所认为的函数式编程的最迷人的地方，但是，貌似也仅此而已。

有什么用啊…? 我也不知道除了写redux的时候就没用过了
这是纯函数被黑的最惨的一次 QwQ


从了解curry开始
恩，函数式编程的世界里的确到处充满着纯函数。可以说纯函数从头">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kimzZ.com/2017/03/29/JS-函数式编程/"/>





  <title> JS-函数式编程 | kimZLeung </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">kimZLeung</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">kimz's Bolg</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://kimzZ.com/2017/03/29/JS-函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="kimZ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/upload.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kimZLeung">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                JS-函数式编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-29T07:03:06+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="以前我眼里的函数式编程"><a href="#以前我眼里的函数式编程" class="headerlink" title="以前我眼里的函数式编程"></a>以前我眼里的函数式编程</h2><blockquote>
<p>纯函数、不影响外部状态、高抽象度… 没… 没了吧。从一而终的纯函数，不受任何外部变量影响，也不影响任何外部变量的高度抽象性。大概就是我所认为的函数式编程的最迷人的地方，但是，貌似也仅此而已。</p>
</blockquote>
<h3 id="有什么用啊…-我也不知道"><a href="#有什么用啊…-我也不知道" class="headerlink" title="有什么用啊…? 我也不知道"></a>有什么用啊…? 我也不知道</h3><h3 id="除了写redux的时候就没用过了"><a href="#除了写redux的时候就没用过了" class="headerlink" title="除了写redux的时候就没用过了"></a>除了写redux的时候就没用过了</h3><blockquote>
<p>这是纯函数被黑的最惨的一次 QwQ</p>
</blockquote>
<hr>
<h2 id="从了解curry开始"><a href="#从了解curry开始" class="headerlink" title="从了解curry开始"></a>从了解curry开始</h2><blockquote>
<p>恩，函数式编程的世界里的确到处充满着纯函数。可以说纯函数从头到尾贯穿了函数式编程！</p>
</blockquote>
<p>那简单的纯函数之后，我们先了解一下对纯函数的一个加强处理 -&gt; <code>curry function</code>（函数柯理化）</p>
<blockquote>
<p>函数柯理化是指把一个函数柯理化，然后柯理化后的函数简单来说…就是可以随便传参。本来传三个参数，可以传一个，然后会返回接受余下参数的新函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">haha</span>(<span class="params">one, two, three</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(one, two, three)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数haha$就是柯理化的haha</span></div><div class="line"><span class="keyword">var</span> haha$ = curry(haha)</div><div class="line"><span class="keyword">var</span> haha$$ = haha$(<span class="number">1</span>)    <span class="comment">// 返回一个函数，这个函数还可以接受两个参数，分别就是上面的two和three</span></div><div class="line">haha$$(<span class="number">2</span>, <span class="number">3</span>)            <span class="comment">// 打印 “1 2 3”</span></div><div class="line"><span class="comment">// 也可以</span></div><div class="line">haha$(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)          <span class="comment">// 打印“1 2 3”</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="柯理化大概就这意思"><a href="#柯理化大概就这意思" class="headerlink" title="柯理化大概就这意思"></a>柯理化大概就这意思</h3><blockquote>
<p>优点：柯理化可以对纯函数进行”预加载”，对参数进行缓存。这为函数组合提供了更灵活的手段，有利于接口专用化。把纯函数变成专用纯函数，降低通用性，提高专用性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 贴上自行实现的curry</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length</span>) </span>&#123;</div><div class="line">    <span class="comment">// 取得函数参数的长度，如果陷入了第二次递归curry自然会使用到length来记住已经被消费的参数</span></div><div class="line">	<span class="keyword">var</span> len = length || fn.length</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	    <span class="comment">// 取得调用时传入的参数的个数</span></div><div class="line">		<span class="keyword">var</span> innerLen = <span class="built_in">arguments</span>.length</div><div class="line">		<span class="comment">// 如果还有剩余未消费(传入)的参数</span></div><div class="line">		<span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; len) &#123;</div><div class="line">		    <span class="comment">// 把fn和这里传入的参数合并起来</span></div><div class="line">			<span class="keyword">var</span> combined = [fn].concat(toArray(<span class="built_in">arguments</span>))</div><div class="line">			<span class="comment">// 尾递归优化，递归调用curry并且使用subCurry把第一个参数（也就是fn）去掉（这一步在调用时才会产生效果），注意传入已剩余参数的长度标记</span></div><div class="line">			<span class="keyword">return</span> curry(subCurry.apply(<span class="keyword">this</span>, combined), len - innerLen)</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		    <span class="comment">// 如果参数已经被消费完了，直接调用apply。若已多次调用上面的curry递归的话，fn已经不是本来的fn了，所以只起执行函数的作用</span></div><div class="line">			<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subCurry</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(toArray(<span class="built_in">arguments</span>)))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="再说说PointFree"><a href="#再说说PointFree" class="headerlink" title="再说说PointFree"></a>再说说PointFree</h2><blockquote>
<p>PointFree其实就是无值的意思。与其说是技术，<code>PointFree</code>倒不如说是一种思想。</p>
</blockquote>
<p>在数学上，函数的意思是固定输入，固定输出，输入的值通过一系列操作输出另一个对应的值。</p>
<p>而<code>PointFree</code>正是反应了这种思想。与输入和输出无关，<code>PointFree</code>反应的是中间这个处理过程。把中间对输入值进行处理的过程拆分成一个又一个很小的<code>纯函数</code>，组合一系列输入输出之后输出正确的结果，所以<code>PointFree</code>就是不使用所要处理的值，只合成运算过程。</p>
<p><code>PointFree</code>不关心要处理的值，只关心要进行处理的过程，所以可以看作一个巨型纯函数。纯函数的确贯穿函数式编程</p>
<blockquote>
<p>其实redux实现中间件的思想是<code>PointFree</code>最明显的体现，通过可自由组合的中间件的<code>compose</code>，把一系列的中间件（纯函数）包装成一个完整的处理过程，包装过后再输入<code>action</code>的时候，将会对<code>action</code>进行不同的处理（当然原来的<code>dispatch</code>会放在最里面，成为最后一个输入输出的小组件用于修改<code>store</code>， 不过中间件有中间件独特的签名）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// compose</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> funcs = toArray(<span class="built_in">arguments</span>)</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">	    <span class="comment">// 返回把函数嵌套起来的结果，类似add(reduce(data))这样的结果，从后面开始调用</span></div><div class="line">		<span class="keyword">return</span> funcs.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">lastRes, func</span>) </span>&#123;</div><div class="line">			<span class="keyword">return</span> func(lastRes)</div><div class="line">		&#125;, data)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arr)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上实现的<code>compose</code>可以用于合并N个纯函数用于合成一个大的纯净处理器</p>
<hr>
<h2 id="容器、Functor"><a href="#容器、Functor" class="headerlink" title="容器、Functor"></a>容器、Functor</h2><blockquote>
<p>终于还是来到了<code>Functor</code>，所谓<code>Functor</code>就是一个包着数据的容器。那为什么需要这个容器呢。回顾一下函数式编程的核心，纯函数：<strong>对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态</strong>。不过实际的编程中，我们不可能不依赖或改变外部环境。这个时候我们就需要一个<code>Functor</code>来装着我们处理的输入，并保证它不与外界接触。<code>Functor</code>是容器，也是隔膜。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Container = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>._value = x</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用一个.of方法代理new</span></div><div class="line">Container.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Container(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们为了另这个输入数据不受影响，用一个容器将其装起来，可是同时普通的函数也无法对其造成影响。所以我们定义了一个接口用于将操作方法传进去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Container.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Container.of(fn(<span class="keyword">this</span>._value))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// we can do this</span></div><div class="line"><span class="keyword">var</span> c = Container.of(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">	c.map(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> data + <span class="number">1</span></div><div class="line">	&#125;).map(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> data - <span class="number">3</span></div><div class="line">	&#125;)</div><div class="line">)   <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(c)  <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// 所以包在容器里不会影响到外部的数据，不依赖外部状态</span></div></pre></td></tr></table></figure>
<p>这个方法的意思是通过<code>Container</code>实例上调用这个方法，传入一个操作的纯函数，对容器里的值进行操作，然后重新把这个值包起来。并且把自己返回回来。</p>
<h3 id="Functor就是实现了map并且遵守一些规则的容器"><a href="#Functor就是实现了map并且遵守一些规则的容器" class="headerlink" title="Functor就是实现了map并且遵守一些规则的容器"></a><strong>Functor就是实现了map并且遵守一些规则的容器</strong></h3><blockquote>
<p><code>Functor</code>还有很多种类：比如<code>Maybe</code>（就是<code>Container</code>多了个判空）</p>
</blockquote>
<p>如果觉得每传入一个函数就要写一次<code>map</code>，我们可以通过<code>PointFree</code>把烦人的<code>map</code>去掉，下面还运用了函数柯理化预设处理函数，这样做可以预设函数，然后随意调用<code>Functor</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把func操作函数放前面，所以可以先传入预设的处理函数，然后再传入Functor可以马上返回任意Functor的map方法</span></div><div class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">func, functor</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> functor.map(func)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// we can do this</span></div><div class="line"><span class="keyword">var</span> c = Container.of(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> data + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> data - <span class="number">2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    map(compose(add, reduce))(c)</div><div class="line">)   <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="built_in">console</span>.log(</div><div class="line">    c.map(compose(add, reduce))</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="关于错误处理、Either"><a href="#关于错误处理、Either" class="headerlink" title="关于错误处理、Either"></a>关于错误处理、Either</h2><blockquote>
<p><code>Either</code>用于错误处理，就跟<code>Functor</code>没多大区别。因为<code>try...catch</code>不纯</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Left = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.__value = x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Right = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.__value = x;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Left.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Left(x);</div><div class="line">&#125;</div><div class="line">Right.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Right(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Left.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">Right.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> Right.of(f(<span class="keyword">this</span>.__value));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>Left</code>就是错误的处理，它的<code>map</code>方法是直接返回自己，而<code>right</code>的<code>map</code>方法是拿出数据，修改，再封回去容器，跟<code>Container</code>一样</p>
<hr>
<h2 id="IO-Functor"><a href="#IO-Functor" class="headerlink" title="IO Functor"></a>IO Functor</h2><blockquote>
<p>与其他<code>Functor</code>不同的是这个容器的<code>._value</code>是一个函数，当调用这个<code>._value</code>的时候才会开始执行</p>
</blockquote>
<hr>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>我看到一句很令人欣喜的话，<strong><code>Promise</code>就是一种<code>Monad</code></strong>。简单来说就是<code>Monad</code>其实就是函数式编程的异步实现。</p>
</blockquote>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li><code>Redux</code>处处充满函数式编程的小细节，每一个<code>reducer</code>就是一个纯函数，<code>combineReducers</code>出来的大<code>Reducer</code>也是纯函数，通过每次<code>dispatch</code>来进行计算出最新的状态，而非全局保存状态。<code>dispatch</code>中实现的中间件机制，也体现了<code>PointFree</code>的思想，<code>compose</code>了一堆方法用于处理输入了<code>action</code></li>
<li><code>RxJS</code>，<code>Rx</code>的神奇之处在于它的响应式编程。用于页面的交互事件和异步请求的处理十分棒。<code>RxJS</code>的链式调用和事件流思想，运用到事件交互上十分方便。<code>RxJS</code>的事件流也是纯函数，固定输入固定输出。</li>
</ul>
<hr>
<p>参考：</p>
<ol>
<li><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="external">阮一峰 - PointFree</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/" target="_blank" rel="external">JS函数式编程指南</a></li>
<li><a href="http://insights.thoughtworkers.org/functional-javascript/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">函数式 - JavaScript</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21714695" target="_blank" rel="external">JavaScript函数式编程系列</a></li>
<li><a href="http://blog.jobbole.com/77956/" target="_blank" rel="external">函数式JavaScript - Curry</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS-函数式编程/" rel="tag"># JS 函数式编程</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/27/start-with-RxJS/" rel="next" title="start-with-RxJS">
                <i class="fa fa-chevron-left"></i> start-with-RxJS
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/upload.jpg"
               alt="kimZ" />
          <p class="site-author-name" itemprop="name">kimZ</p>
           
              <p class="site-description motion-element" itemprop="description">Share what we play</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#以前我眼里的函数式编程"><span class="nav-number">1.</span> <span class="nav-text">以前我眼里的函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有什么用啊…-我也不知道"><span class="nav-number">1.1.</span> <span class="nav-text">有什么用啊…? 我也不知道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#除了写redux的时候就没用过了"><span class="nav-number">1.2.</span> <span class="nav-text">除了写redux的时候就没用过了</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从了解curry开始"><span class="nav-number">2.</span> <span class="nav-text">从了解curry开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#柯理化大概就这意思"><span class="nav-number">2.1.</span> <span class="nav-text">柯理化大概就这意思</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再说说PointFree"><span class="nav-number">3.</span> <span class="nav-text">再说说PointFree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器、Functor"><span class="nav-number">4.</span> <span class="nav-text">容器、Functor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Functor就是实现了map并且遵守一些规则的容器"><span class="nav-number">4.1.</span> <span class="nav-text">Functor就是实现了map并且遵守一些规则的容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于错误处理、Either"><span class="nav-number">5.</span> <span class="nav-text">关于错误处理、Either</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-Functor"><span class="nav-number">6.</span> <span class="nav-text">IO Functor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad"><span class="nav-number">7.</span> <span class="nav-text">Monad</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实际应用"><span class="nav-number">8.</span> <span class="nav-text">实际应用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kimZ</span>
</div>


<div class="powered-by">
  KimZ
</div>

<div class="theme-info">
  to be lazyer, to be nicer
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
